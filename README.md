# SberSchoolLesson19HWK & SberSchoolLesson20HWK & SberSchoolLesson21HWK & SberSchoolLesson24HWK & SberSchoolLesson31HWK
-----------------------------------------------------------------------------------------------------------------------------------------------------
## Лекция 19. MV* паттерны в Android(MVP/MVVM).

### Выбрать понравившийся публичный сервис https://github.com/public-apis/public-apis и на основе этого сервиса реализовать приложение, в котором должно быть следующее:
1. Как минимум 2-3 экрана (можно больше), один из которых со списком, второй с детальной информацией по выбранному элементу списка.
2. Данные должны загружаться по сети с помощью OkHttp.
3. Для многопоточность используем RxJava2 (Single/Maybe/Completable).
4. Презентационный слой реализован по шаблону MVVM. Для каждого экрана должна быть своя ViewModel.
5. Приложение должно корректно обрабатывать возможные ошибки (через отображение диалога об ошибке), уметь отображать процесс загрузки данных. Обратите внимание на сетевые ошибки, в частности.
6. Старайтесь разбивать по слоям бизнес-логику.
7. На публичные методы, классы, конструкторы есть документация, оформленная согласна принятым стандартам JavaDoc/KotlinDoc.
8. Присутствует файлик Readme, с текстовым описанием приложения, архитектуры, сервиса, который вы используете.
9. Можно (но не обязательно) использовать DataBinding/ViewBinding.
10. Unit-тестирование вы будете подробнее проходить на следующем занятии - можете пока попробовать.
----------------------------------------------------------------------------------------------------------------------------------------------------- 
### Реализация

Используемый язык программирования: Kotlin  
Публичный сервис Апи: https://travelbriefing.org/

Архитектура проекта: MVVM  
Технологии:  
    RXJava2 - работа с асинхронным кодом,  
    RxAndroid - расширение RxJava для Android,  
    Retrofit - работа с АПИ сервиса со встроенным Json парсером на базе OkHttp,  
    OkHttp - обработчик сетевых запросов,  
    LiveData - хранилища с возможностью наблюдения за приходящими данными,  
    Mockito - тестирование приложения.  
   
Функционал: 
- Приложение получает список стран с открытого сервиса и позволяет пользователю посмотреть справочную информацию по ним. 
- Приложение отображает статус загрузки данных
- Приложение обрабатывает ошибки и отображает их во всплывающих подсказках
-----------------------------------------------------------------------------------------------------------------------------------------------------
## Лекция 20. Unit Tests.

### Написать тесты на проект предыдущей лекции. 


### Замечания:
- Тест на каждый класс должен быть в отдельном файле. 
- Расположение по пакетам - тесты должны лежать в тех же пакетах, что и тестируемые классы. Помимо эстетического удовольствия, у тебя есть область видимость классов и методов. Дефолтные и протектные классы и методы, которые доступны классу станут недоступны тесту, если ты положишь его в другой пакет. Структуру пакетов поддерживать просто, жмёшь у классов кнопку "сгенерить тест" и пакеты создадутся автоматически, даже при перемещении классов студия сама предложит переместить соотвествующий тест в новый пакет
- Названия тестов - по код-конвенции тест называется ИмяКлассаTest. Тоже не просто так, а чтобы студия понимала какой тест для какого класса - помогает при генерации test coverage и для рефактора при переименовании класса и перемещении из пункта выше. Генерация теста так же даёт название такого вида 
- Тесты надо писать на все публичные методы всех классов доменного и дата слоя. Иначе кто-нибудь наменяет эти простенькие методы и поломает проект, а ты и не узнаешь
-----------------------------------------------------------------------------------------------------------------------------------------------------
## Лекция 21. Фон. Практика.

### Переписать приложение с прошлых занятий на чистую архитектуру. 
-----------------------------------------------------------------------------------------------------------------------------------------------------
## Лекция 24. Dagger 2.

### Взять за основу свой выпускной проект или на базе одного из тех, что делался для домашних заданий. Реализовать предоставление зависимостей через Dagger компоненты. Для выполнения домашнего задания достаточно одного компонента. Но будет очень полезно реализовать для лучшего понимания темы несколько уровней компонентов через Component.dependencies или через Subcomponent. 
-----------------------------------------------------------------------------------------------------------------------------------------------------
## Лекция 31. UI-тесты.

### Покрыть UI–тестами домашнее задание 24. 
-----------------------------------------------------------------------------------------------------------------------------------------------------